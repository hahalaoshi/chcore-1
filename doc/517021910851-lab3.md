## ChCore Lab 3: User Processes
517021910851-于亚杰
### Part A: User Processes
**Exercise 1**:
> Find and finish the following functions:

+ `load_binary`: Use `ROUND_UP` to align `seg_map_sz`. Use `memcpy` to copy the data from binary to pmo with virtual address. `phys_to_virt` is needed to do the translation.
+ `init_thread_ctx`: Set the three registers values in the thread context.
+ `switch_context`: Return the context pointer of the thread.

**Exercise 2**:
>  Please briefly describe what `process_create_root` has 
>done. **NOTE**: a detailed description of the logic in function ``thread_create_main`` is required and drawing call graphs is recommended.

calling graph(details not very important are hidden):
+ `process_create_root`
  + `ramdisk_read_file`
  + `process_create`
    + `process_init`
    + `vmspace_init`
  + `thread_create_main`
    + `vmspace_map_range`
    + ` load_binary`
      + `elf_parse_file`
      +  `vmspace_map_range`
    + `prepare_env`
    + `thread_init`
      + `create_thread_ctx`
      + `init_thread_ctx`
 
`process_create_root` is aimed to create the root process following the steps shown below.
1. Read the binary file.`ramdisk_read_file` read the binary with the binary name.
2. Create a process. Allocate memory for the process and then initialize the process and `vmspace`.  
3. Create a main thread for this process. First get the vmspace of the process and then allocate and setup a user stack for the init thread. 
    Then map the stack memory to the vmspace. With `load_binary` the data is loaded from elf to the process. The elf will be parsed and the program memory will be mapped.
    After loading the binary, environment is prepared and thread is initialized, during which the thread context is created and set. Last step is to flush dcache and icache.
4. Put init thread into the ready queue. 
### Part B: Exception Handling
**Exercise 3:**
 > Edit `exception_table.S` and `exception.c` to implement the features described above. You should：
+ > Fill in the exception vector table in exception_table.S with the help of some macros in that file.
  + add exception entries under `EXPORT(el1_vector)`, the sequence is determined according to the document.
+ > Complete the exception_init function in exception.c to set up the exception vector after kernel have been booted.
  + invoke `set_exception_vector()`
+ > Handle bad instruction exception by let the kernel print info of macroUNKNOWN defined in esr.h with kinfo(UNKNOWN) and call sys_exit(-ESUPPORT) in the handler to let the user thread exit, since such kind of exception is unable to be recovered.
  + for exception class of `ESR_EL1_EC_UNKNOWN`, print unknown and exit.
  
### Part C: System Calls and Page Faults
**Exercise 4:**
> Dislike other exceptions in ChCore, system calls are handled by directly jump to the corresponding system call entry in the `syscall_table` using assembly code. Please read the code in `exception_table.S` and briefly describe how a system call is dispatched from the exception vector table to a entry of the system call table in your document.

System call first is treated as `sync_el0_64` exception in exception vector table. Then in `sync_el0_64` the `esr_el1` would be checked. If it's a svc_64 exception, the program will branch to `el0_syscall` which can find the syscall entry in the syscall table according to the system number and branch there.

**Exercise 5:**
> Complete `syscall` in `/user/lib/syscall.c` which use `SVC` instruction to trap into kernel and execute the system call. Don't forget to make user after your modification.

I guess `arg8` is reserved in order to avoid overwriting live register x8. Use `mov` instruction to prepare the arguments and also the system call number. `svc #0` is used to execute the system call.

**Exercise 6:**
> Finish the following system calls in ChCore.

Invoke syscall in `usys_***` and add these syscall handler to the `syscall_table.`
+ > `sys_putc`: Use `uart_send` to put a char onto the screen. This is a basic system call used by `printf`.
  + use `uart_send` to print the character
+ > `sys_exit`: The helper function `sys_exit` will exit a thread as we mentioned before in exercise 3. Now, you can dispatch corresponding system call to `sys_exit`.
  + nothing to do
+ > `sys_create_pmo`: The implementation of this function is in `vm_syscall.c` and will be used later to  test page fault.
  + nothing to do
+ > `sys_map_pmo`: The implementation of this function is in `vm_syscall.c` and will be used later to test page fault.
  + nothing to do
+ > (Bonus) `sys_handle_brk`: user thread will use `sys_handle_brk` to create or expand the user heap.  In this system call, the heap of the current function will be enlarged to the virtual address addr. More details of this function can be found in the comment of `vm_syscall.c`. If you are not going to finish this function, don't forget to remove its current existing code to eliminate warnings.
  + If `addr` equals 0, initialize a pmo and vmr.
  + If `addr` > top of the heap, add `vmr->size` and `pmo->size` by `addr` - top of the heap. 
  + otherwise, set `retval` or error.

**Exercise 7:**
> Please check the execution flow after the ret instruction in function START has been executed with GDB. Try to explain this phenomenon briefly in your document.

```
# now pc points to ret
(gdb) n
Single stepping until exit from function main,
which has no line number information.
0x0000000000000000 in ?? ()
```
`b 0x400110<main>` this is not a subroutine call so the return address is not set. When return instruction is executed, the value of register x30 is 0, which means the next pc would be 0.
Therefore, the result above shows that the program is branched to address 0x0 and has nothing to do there.

**Exercise 8:**
> Add call to `sys_exit` system call in `/user/lib/libmain.c` to let the main thread exit gracefully.

I added `usys_exit(0)` to do the system call.

**Exercise 9:**
> Modify `handle_entry_c()` to dispatch page fault exceptions to `do_page_fault()` and finish the `do_page_fault()` function.

The keypoint is to follow the hints, which is kinda too detailed I guess. 
Find the corresponding `vmregion` for the `fault_addr`, alloc a page, set the `pmo` and do the page mapping with `map_range_in_pgtbl`.

